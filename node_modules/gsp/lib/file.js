'use strict';

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var async = require('async');
var gspdata = require('./util/gspdata');
var fs = require('fs-extra');
var glob = require('glob');
var isBinaryPath = require('is-binary-path');
var path = require('path');

var $fileCache = {};

var File = (function () {
    function File(workdir, filename, config) {
        _classCallCheck(this, File);

        if (filename) {
            filename = filename.split(path.sep).join('/');
        }
        this.workdir = workdir;
        this.filename = filename;
        this.config = config;
        this.filedata = null;
    }

    _createClass(File, [{
        key: 'get',
        value: function get(key) {
            return this[key];
        }
    }, {
        key: 'set',
        value: function set(key, value) {
            if (key === 'filename' && value) {
                value = value.split(path.sep).join('/');
            }
            this[key] = value;
        }
    }, {
        key: 'read',
        value: function read(callback) {
            var _this = this;

            var filename = path.join(this.workdir, this.filename);
            if (fs.existsSync(filename)) {
                var _ret = (function () {
                    var mtime = fs.statSync(filename).mtime.getTime();
                    if ($fileCache[filename]) {
                        if ($fileCache[filename].mtime === mtime) {
                            callback(null, $fileCache[filename].content);
                            return {
                                v: undefined
                            };
                        } else {
                            $fileCache[filename] = null;
                        }
                    }
                    var filedata = fs.readFileSync(filename);
                    if (isBinaryPath(filename)) {
                        _this.filedata = filedata;
                        $fileCache[filename] = {
                            content: filedata,
                            mtime: mtime
                        };
                        callback(null, filedata);
                        return {
                            v: undefined
                        };
                    }
                    _this.filedata = filedata.toString();
                    _this.preprocess(function (err) {
                        if (!err) {
                            $fileCache[filename] = {
                                content: _this.filedata,
                                mtime: mtime
                            };
                        }
                        callback(err, _this.filedata);
                    });
                })();

                if (typeof _ret === 'object') return _ret.v;
            } else {
                if ($fileCache[filename]) {
                    $fileCache[filename] = null;
                }
                callback(new Error(filename + ' doesn\'t exist'));
            }
        }
    }, {
        key: 'preprocess',
        value: function preprocess(callback) {
            var _this2 = this;

            var preprocessorConfig = this.config.preprocessors;
            async.eachSeries(Object.keys(preprocessorConfig), function (extname, callback) {
                if (path.extname(_this2.get('filename')).slice(1) === extname) {
                    async.eachSeries(preprocessorConfig[extname], function (preprocessor, callback) {
                        var mod = undefined;
                        try {
                            mod = require('./preprocessors/' + preprocessor);
                        } catch (e) {
                            callback();
                            return;
                        }
                        mod(_this2, callback);
                    }, callback);
                } else {
                    callback();
                }
            }, callback);
        }
    }]);

    return File;
})();

File.$inject = ['workdir', 'filename', 'config'];

var Concat = (function (_File) {
    _inherits(Concat, _File);

    function Concat() {
        _classCallCheck(this, Concat);

        _get(Object.getPrototypeOf(Concat.prototype), 'constructor', this).call(this);
        this.concatconfig = null;
    }

    _createClass(Concat, [{
        key: 'read',
        value: function read(callback) {
            var _this3 = this;

            if (isBinaryPath(this.filename)) {
                _get(Object.getPrototypeOf(Concat.prototype), 'read', this).call(this, callback);
            } else {
                this.getconcatconfig(function (err, concatconfig) {
                    if (err) {
                        callback(err);
                    } else {
                        _this3.concatconfig = concatconfig;
                        _this3.concatFiles(_this3.filename, callback);
                    }
                });
            }
        }
    }, {
        key: 'getconcatconfig',
        value: function getconcatconfig(callback) {
            var file = new File(this.workdir, 'concatfile.json', this.config);
            file.read(function (err, filedata) {
                if (err) {
                    callback(null, {});
                } else {
                    try {
                        filedata = JSON.parse(filedata);
                    } catch (e) {
                        callback(new Error('concatfile.json isn\'t a valid JSON file.'));
                        return;
                    }
                    callback(null, filedata);
                }
            });
        }
    }, {
        key: 'concatFiles',
        value: function concatFiles(filename, callback) {
            var _this4 = this;

            var flattenFiles = [];

            if (!this.concatconfig.pkg[filename]) {
                this.concatconfig.pkg[filename] = [filename.replace(path.extname(filename), '.*')];
            } else if (typeof this.concatconfig.pkg[filename] === 'string') {
                this.concatconfig.pkg[filename] = [this.concatconfig.pkg[filename]];
            }

            async.eachSeries(this.concatconfig.pkg[filename], function (file, c) {
                var ignore = false;
                if (file.indexOf('!') === 0) {
                    file = file.slice(1);
                    ignore = true;
                }
                _this4.flattenFiles(file, function (err, files) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var f = _step.value;

                            var index = flattenFiles.indexOf(f);
                            if (index === -1) {
                                if (!ignore) {
                                    flattenFiles.push(f);
                                }
                            } else {
                                if (ignore) {
                                    flattenFiles.splice(index, 1);
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator['return']) {
                                _iterator['return']();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    c();
                });
            }, function () {

                async.mapSeries(flattenFiles, function (file, c) {
                    var ext = _this4.concatconfig.ext && _this4.concatconfig.ext[file];
                    if (ext) {
                        if (gspdata.get('repositories', ext.repo)) {
                            _this4.getExternalFile(gspdata.get('repositories', ext.repo), ext.uri, c);
                        } else {
                            c(new Error('Repository ' + ext.repo + ' doesn\'t exits'));
                        }
                    } else if (_this4.concatconfig.pkg[file] && file !== filename) {
                        _this4.concatFiles(file, c);
                    } else {
                        file = new File(_this4.workdir, file, _this4.config);
                        file.read(function (err, filedata) {
                            if (!err) {
                                filedata = '/* from ' + path.join(file.get('workdir'), file.get('filename')) + ' */\n' + filedata;
                                var orignalFilename = _this4.get('filename');
                                _this4.set('filename', orignalFilename.slice(0, -path.extname(orignalFilename).length) + path.extname(file.get('filename')));
                            }
                            c(err, filedata);
                        });
                    }
                }, function (err, result) {
                    callback(err, result.join('\n'));
                });
            });
        }
    }, {
        key: 'flattenFiles',
        value: function flattenFiles(filename, callback) {
            if (filename.indexOf('*') === -1) {
                callback(null, [filename]);
                return;
            }
            callback(null, glob.sync(filename, { cwd: this.workdir }));
        }
    }, {
        key: 'getExternalFile',
        value: function getExternalFile(repoPath, filename, callback) {
            var config = fs.readJSONSync(path.join(repoPath, '.gspconfig'), { throws: false }) || {};
            var file = new Concat();
            file.set('workdir', repoPath);
            file.set('filename', filename);
            file.set('config', config);
            file.read(callback);
        }
    }]);

    return Concat;
})(File);

Concat.$inject = [];

exports.File = File;
exports.Concat = Concat;

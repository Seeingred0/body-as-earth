'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var chalk = require('chalk');
var chokidar = require('chokidar');
var di = require('di');
var fs = require('fs-extra');
var gspdata = require('./util/gspdata');
var glob = require('glob');
var minimatch = require('minimatch');
var path = require('path');
var tinylr = require('tiny-lr');
var lint = require('./lint');

var concatConfigs = {};

var parseConcatConfig = function parseConcatConfig(repoLocation) {
    var c = fs.readJSONSync(path.join(repoLocation, 'concatfile.json'), { throws: false }) || {};
    c.pkg = c.pkg || {};
    c.ext = c.ext || {};
    c.rfs = {};
    Object.keys(c.pkg).forEach(function (pkgPath) {
        var flattenFiles = [];
        if (!Array.isArray(c.pkg[pkgPath])) {
            c.pkg[pkgPath] = [c.pkg[pkgPath]];
        }
        c.pkg[pkgPath].forEach(function (filepath) {
            var ignore = false,
                index = undefined;
            if (filepath.indexOf('!') === 0) {
                filepath = filepath.slice(1);
                ignore = true;
            }
            if (filepath.indexOf('*') === -1) {
                index = flattenFiles.indexOf(filepath);
                if (index === -1) {
                    if (!ignore) {
                        flattenFiles.push(filepath);
                    }
                } else {
                    if (ignore) {
                        flattenFiles.splice(index, 1);
                    }
                }
            } else {
                glob.sync(filepath, { cwd: repoLocation }).forEach(function (filepath) {
                    index = flattenFiles.indexOf(filepath);
                    if (index === -1) {
                        if (!ignore) {
                            flattenFiles.push(filepath);
                        }
                    } else {
                        if (ignore) {
                            flattenFiles.splice(index, 1);
                        }
                    }
                });
            }
        });
        c.pkg[pkgPath] = flattenFiles;
    });
    Object.keys(c.pkg).forEach(function (pkgPath, index, pkgArray) {
        var rfs = [];
        pkgArray.slice(0, index).concat(pkgArray.slice(index)).forEach(function (pkgPathOther) {
            c.pkg[pkgPathOther].some(function (filepath) {
                if (minimatch(pkgPath, filepath)) {
                    rfs.push(pkgPathOther);
                }
            });
        });
        c.rfs[pkgPath] = rfs;
    });
    return c;
};

var findFileSync = function findFileSync(filename, start, stop) {
    var filepath = path.join(start, filename),
        last = null;
    while (start !== stop && start !== last) {
        if (fs.existsSync(filepath)) {
            return filepath;
        }
        last = start;
        start = path.dirname(start);
        filepath = path.join(start, filename);
    }
};

var findRelateFiles = function findRelateFiles(pathname, concatConfig) {
    var relateFiles = [pathname];
    var antiCompile = function antiCompile(filepath) {
        concatConfig.rfs[filepath].forEach(function (f) {
            if (relateFiles.indexOf(f) === -1) {
                relateFiles.push(f);
                antiCompile(f);
            }
        });
    };

    if (concatConfig.pkg[pathname]) {
        antiCompile(pathname);
    } else {
        Object.keys(concatConfig.pkg).forEach(function (pkgPath) {
            concatConfig.pkg[pkgPath].some(function (filepath) {
                if (minimatch(pathname, filepath)) {
                    relateFiles.push(pkgPath);
                    antiCompile(pkgPath);
                    return true;
                } else {
                    return false;
                }
            });
        });
    }

    return relateFiles;
};

var LiveReload = (function () {
    function LiveReload() {
        _classCallCheck(this, LiveReload);

        this.server = tinylr();
        this.server.listen(35729, function () {
            console.log('LiveReload server listening on port 35729');
        });
    }

    _createClass(LiveReload, [{
        key: 'reload',
        value: function reload() {
            for (var _len = arguments.length, files = Array(_len), _key = 0; _key < _len; _key++) {
                files[_key] = arguments[_key];
            }

            console.log(chalk.cyan('This causes follow publish file(s) changed, refreshing browsers...'));
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var file = _step.value;

                    console.log(file);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.server.changed({ body: { files: files } });
        }
    }]);

    return LiveReload;
})();

var watch = function watch(options, gspdata, lint, livereload) {
    var watcher = chokidar.watch(options.cwd, { ignored: /\.git|node_modules/ });
    console.log('Waiting for changes');
    watcher.on('change', function (filepath) {

        var gspconfig = findFileSync('.gspconfig', filepath, options.cwd);

        if (!gspconfig) {
            return;
        }

        var repoId = path.basename(path.dirname(gspconfig));
        var repoLocation = gspdata.get('repositories', repoId);
        var pathname = path.relative(repoLocation, filepath);

        gspconfig = fs.readJSONSync(gspconfig, { throws: false }) || {};

        console.log('\n%s changed', path.join(repoId, pathname));

        var problems = lint.lintFiles([pathname], gspconfig.lint);

        if (problems) {
            return;
        }

        if (!livereload) {
            return;
        }

        if (pathname === 'concatfile.json') {
            concatConfigs[repoId] = parseConcatConfig(repoLocation);
            return;
        }
        var concatConfig = concatConfigs[repoId];
        if (!concatConfig) {
            concatConfig = concatConfigs[repoId] = parseConcatConfig(repoLocation);
        }

        var relateFiles = findRelateFiles(pathname, concatConfig);

        relateFiles = relateFiles.map(function (filepath) {
            return path.relative(gspconfig.publish_dir, filepath);
        });

        relateFiles = relateFiles.filter(function (filepath) {
            return filepath.indexOf('..') !== 0;
        });

        relateFiles = relateFiles.map(function (filepath) {
            return path.join(gspconfig.mapping_dir, filepath);
        });

        if (relateFiles.length) {
            livereload.reload.apply(livereload, _toConsumableArray(relateFiles));
        }
    });
};

exports.watch = function (options) {
    var module = {
        options: ['value', options],
        gspdata: ['value', gspdata],
        lint: ['value', lint]
    };
    if (options.livereload) {
        module.livereload = ['type', LiveReload];
    } else {
        module.livereload = ['value', false];
    }
    var injector = new di.Injector([module]);
    injector.invoke(watch);
};

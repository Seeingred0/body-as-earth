'use strict';

var chalk = require('chalk');
var child_process = require('child_process');
var di = require('di');
var gspdata = require('./util/gspdata');
var file = require('./file');
var fs = require('fs-extra');
var http = require('http');
var mine = require('mime');
var path = require('path');
var url = require('url');
var watch = require('./watch');

var readfile = function readfile(pathname, file, callback) {
    var repoMapping = gspdata.get('mapping');
    var repoId = undefined,
        filename = undefined;
    Object.keys(repoMapping).some(function (mappingDir) {
        var mappingDirfixed = mappingDir.replace(/^\/*/, '/').replace(/\/*$/, '/');
        if (pathname.indexOf(mappingDirfixed) === 0) {
            repoId = repoMapping[mappingDir];
            filename = pathname.slice(mappingDirfixed.length);
            return true;
        }
    });

    if (repoId) {
        var workdir = gspdata.get('repositories', repoId);
        var config = fs.readJSONSync(path.join(workdir, '.gspconfig'), { throws: false }) || {};
        filename = path.join(config.publish_dir || '', filename);
        file.set('workdir', workdir);
        file.set('filename', filename);
        file.set('config', config);
        file.read(callback);
    } else {
        callback(new Error('Git repository lacks.'));
    }
};

var start = function start(options, watch, file) {

    options.port = options.port || 7070;

    var server = http.createServer();
    server.on('listening', function (err) {
        if (err) {
            console.error(chalk.red('Gsp simulator failed to start'));
        } else {
            console.log('Gsp simulator started, listening on port %s', options.port);
            if (options.livereload) {
                watch({
                    livereload: true
                });
            }
        }
    });
    server.on('request', function (request, response) {
        var pathname = url.parse(request.url).pathname;
        var output = function output(code, data) {
            if (data) {
                data = new Buffer(data);
                response.writeHeader(code, { 'content-type': mine.lookup(pathname), 'content-length': data.length });
                response.end(data);
            } else {
                response.end();
            }
        };
        readfile(pathname, file, function (err, filedata) {
            console.log('GET: ' + pathname);
            if (err) {
                console.error(chalk.bold.white.bgRed(' ERROR ') + ' ' + err.message);
                if (filedata) {
                    output(502);
                } else {
                    output(404);
                }
            } else {
                output(200, filedata);
            }
        });
    });
    server.listen(options.port);
};

exports.readfile = function (pathname, callback) {
    var injector = new di.Injector([{
        pathname: ['value', pathname],
        file: ['type', file.Concat],
        callback: ['value', callback]
    }]);
    injector.invoke(readfile);
};

exports.start = function (options) {
    if (options.daemon) {
        delete options.daemon;
        var args = process.argv.filter(function (arg) {
            return arg !== '-d' && arg !== '--daemon';
        });
        args.shift();
        var out = fs.openSync('out.log', 'a');
        child_process.spawn(args.shift(), args, {
            detached: true,
            stdio: ['ignore', out, out]
        });
    } else {
        var injector = new di.Injector([{
            options: ['value', options],
            watch: ['value', watch.watch],
            file: ['type', file.Concat]
        }]);
        injector.invoke(start);
    }
};
